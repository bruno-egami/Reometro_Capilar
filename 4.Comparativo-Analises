# -----------------------------------------------------------------------------
# SCRIPT PARA COMPARAÇÃO E ANÁLISE DE DADOS REOLÓGICOS
# --- VERSÃO COM AJUSTE AUTOMÁTICO DE MODELOS PARA DADOS IMPORTADOS ---
# -----------------------------------------------------------------------------

import os
import glob
import json
import re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# Tenta importar as bibliotecas necessárias para o ajuste de curvas.
# Se não estiverem instaladas, o script ainda funcionará para plotar, mas não ajustará novos modelos.
try:
    from scipy.optimize import curve_fit
    from sklearn.metrics import r2_score
    MODEL_FITTING_ENABLED = True
except ImportError:
    MODEL_FITTING_ENABLED = False
    print("AVISO: Bibliotecas 'scipy' e 'scikit-learn' não encontradas.")
    print("       O script não poderá ajustar novos modelos para os dados importados.")
    print("       Para habilitar, instale com: pip install scipy scikit-learn")


# -----------------------------------------------------------------------------
# --- DEFINIÇÕES DOS MODELOS REOLÓGICOS ---
# -----------------------------------------------------------------------------

# Cada função representa um modelo reológico que relaciona a taxa de cisalhamento (gd)
# com a tensão de cisalhamento (tau).
def model_newtonian(gd, eta): return eta * gd
def model_power_law(gd, K_pl, n_pl): return K_pl * np.power(np.maximum(gd, 1e-9), n_pl)
def model_bingham(gd, t0, ep): return t0 + ep * gd
def model_hb(gd, t0, K_hb, n_hb): return t0 + K_hb * np.power(np.maximum(gd, 1e-9), n_hb)
def model_casson(gd, tau0_cas, eta_cas):
    sqrt_tau0 = np.sqrt(np.maximum(tau0_cas, 0))
    sqrt_eta_cas_val = np.sqrt(np.maximum(eta_cas, 1e-9))
    sqrt_gd_val = np.sqrt(np.maximum(gd, 1e-9))
    return (sqrt_tau0 + sqrt_eta_cas_val * sqrt_gd_val)**2

# Dicionário de modelos com suas respectivas funções e limites (bounds) para os parâmetros.
# Os limites forçam os parâmetros a serem fisicamente realistas (ex: não negativos).
MODELS = {
    "Newtoniano": (model_newtonian, ([0], [np.inf])),
    "Lei da Potência": (model_power_law, ([0, 0], [np.inf, np.inf])),
    "Bingham": (model_bingham, ([0, 0], [np.inf, np.inf])),
    "Herschel-Bulkley": (model_hb, ([0, 0, 0], [np.inf, np.inf, np.inf])),
    "Casson": (model_casson, ([0, 0], [np.inf, np.inf]))
}

# -----------------------------------------------------------------------------
# --- FUNÇÕES DE CARREGAMENTO, SELEÇÃO E AJUSTE ---
# -----------------------------------------------------------------------------

def selecionar_pastas_analise(caminho_base):
    """
    Lista as pastas de análise disponíveis e solicita ao usuário que selecione
    quais deseja comparar.
    """
    print("="*60)
    print("--- SELECIONAR ANÁLISES PARA COMPARAÇÃO ---")
    print("="*60)
    
    try:
        pastas_disponiveis = sorted([d for d in os.listdir(caminho_base) if os.path.isdir(os.path.join(caminho_base, d))])
        if not pastas_disponiveis:
            print(f"ERRO: Nenhuma pasta de análise encontrada em '{caminho_base}'.")
            return None

        print("Análises disponíveis:")
        for i, pasta in enumerate(pastas_disponiveis):
            print(f"  {i+1}: {pasta}")
        
        pastas_selecionadas = []
        while not pastas_selecionadas:
            try:
                escolha_str = input("\nDigite os NÚMEROS das análises a comparar, separados por vírgula (ex: 1, 3, 4): ")
                indices_escolhidos = [int(i.strip()) - 1 for i in escolha_str.split(',')]
                
                if any(i < 0 or i >= len(pastas_disponiveis) for i in indices_escolhidos):
                    raise ValueError("Um ou mais números estão fora do intervalo válido.")
                    
                pastas_selecionadas = [os.path.join(caminho_base, pastas_disponiveis[i]) for i in indices_escolhidos]
                
            except ValueError as e:
                print(f"ERRO: Entrada inválida. ({e})")
            except Exception as e:
                print(f"Ocorreu um erro inesperado: {e}")
                return None
                
        print("\nAnálises selecionadas para comparação:")
        for pasta in pastas_selecionadas:
            print(f"  - {os.path.basename(pasta)}")
            
        return pastas_selecionadas

    except FileNotFoundError:
        print(f"ERRO: O diretório base '{caminho_base}' não foi encontrado.")
        return None

def ajustar_modelos_reologicos(df):
    """
    Ajusta todos os modelos reológicos aos dados, usando limites para garantir
    parâmetros fisicamente realistas. Retorna os resultados e o melhor modelo.
    """
    if not MODEL_FITTING_ENABLED:
        return None, None

    print(f"INFO: Realizando o ajuste de modelos reológicos...")
    
    x_data = df['γ̇w (s⁻¹)'].values
    y_data = df['τw (Pa)'].values
    
    modelos_ajustados = {}
    for name, (model_func, bounds) in MODELS.items():
        try:
            import inspect
            param_names = list(inspect.signature(model_func).parameters.keys())[1:]
            
            p0 = [1.0] * len(param_names)
            
            # Usa limites (bounds) para forçar parâmetros positivos e mais estáveis.
            params, _ = curve_fit(model_func, x_data, y_data, p0=p0, bounds=bounds, maxfev=10000)
            
            y_pred = model_func(x_data, *params)
            r2 = r2_score(y_data, y_pred)
            
            # Ignora modelos com R² negativo, pois indicam um ajuste muito ruim.
            if r2 < 0:
                print(f"  - Modelo '{name}' descartado (R² = {r2:.4f}, ajuste inadequado).")
                continue

            modelos_ajustados[name] = {
                'params': list(params),
                'param_names': param_names,
                'R2': r2
            }
            print(f"  - Modelo '{name}' ajustado com R² = {r2:.4f}")

        except Exception as e:
            print(f"  - AVISO: Não foi possível ajustar o modelo '{name}'. Erro: {e}")

    if not modelos_ajustados:
        print("AVISO: Nenhum modelo pôde ser ajustado com sucesso.")
        return None, None

    best_model_name = max(modelos_ajustados, key=lambda name: modelos_ajustados[name]['R2'])
    
    modelo_info = {
        "name": best_model_name,
        "params": modelos_ajustados[best_model_name]['params']
    }
    
    print(f"INFO: Melhor modelo encontrado: '{best_model_name}' (R² = {modelos_ajustados[best_model_name]['R2']:.4f})")
    return modelos_ajustados, modelo_info


def carregar_dados_completos(caminho_pasta):
    """
    Carrega dados de uma pasta. Primeiro, procura por um arquivo JSON com parâmetros.
    Se não encontrar, carrega qualquer arquivo CSV, realiza o ajuste de modelos
    e cria um novo arquivo JSON com os resultados do ajuste.
    """
    nome_base = os.path.basename(caminho_pasta)
    df = None
    modelo_info = None
    
    padrao_json = os.path.join(caminho_pasta, '*_parametros_modelos.json')
    arquivos_json = glob.glob(padrao_json)
    
    if arquivos_json:
        try:
            with open(arquivos_json[0], 'r', encoding='utf-8') as f:
                params_data = json.load(f)
            modelos_ajustados = params_data.get("modelos_ajustados", {})
            if modelos_ajustados:
                best_model_name = max(modelos_ajustados, key=lambda name: modelos_ajustados[name].get('R2', 0))
                modelo_info = {
                    "name": best_model_name,
                    "params": modelos_ajustados[best_model_name]['params']
                }
        except Exception as e:
            print(f"ERRO ao ler ou processar o arquivo JSON existente em '{nome_base}': {e}")
    
    padrao_csv = os.path.join(caminho_pasta, '*.csv')
    arquivos_csv = glob.glob(padrao_csv)
    
    if not arquivos_csv:
        print(f"AVISO: Nenhum arquivo CSV encontrado em '{nome_base}'. Pulando.")
        return None, None
    
    if len(arquivos_csv) > 1:
        print(f"AVISO: Múltiplos arquivos CSV encontrados em '{nome_base}'. Usando o primeiro: '{os.path.basename(arquivos_csv[0])}'")
    
    caminho_csv_usado = arquivos_csv[0]

    try:
        separator = ';' 
        decimal_sep = ','
        with open(caminho_csv_usado, 'r', encoding='utf-8-sig') as f:
            header = f.readline()
            if header.count(',') > header.count(';'):
                separator = ','
                decimal_sep = '.'
        
        df = pd.read_csv(caminho_csv_usado, sep=separator, decimal=decimal_sep, encoding='utf-8-sig')
        df.columns = df.columns.str.strip()

        col_gamma = 'γ̇w (s⁻¹)'
        col_eta = 'η (Pa·s)'
        col_tau = 'τw (Pa)'

        if not all(col in df.columns for col in [col_gamma, col_eta]):
            raise KeyError(f"O CSV deve conter pelo menos as colunas '{col_gamma}' e '{col_eta}'.")

        for col in [col_gamma, col_eta]:
            if pd.api.types.is_string_dtype(df[col]):
                df[col] = df[col].str.replace(',', '.', regex=False).astype(float)
            else:
                df[col] = pd.to_numeric(df[col])

        if col_tau not in df.columns:
            print(f"INFO: Em '{nome_base}', a coluna '{col_tau}' não foi encontrada. Será calculada (τ = η * γ̇).")
            df[col_tau] = df[col_eta] * df[col_gamma]
        else:
            if pd.api.types.is_string_dtype(df[col_tau]):
                df[col_tau] = df[col_tau].str.replace(',', '.', regex=False).astype(float)
            else:
                df[col_tau] = pd.to_numeric(df[col_tau])

        df.dropna(subset=[col_gamma, col_tau, col_eta], inplace=True)
        
    except Exception as e:
        print(f"ERRO ao ler o arquivo CSV '{os.path.basename(caminho_csv_usado)}' em '{nome_base}': {e}")
        return None, None

    if modelo_info is None and df is not None and not df.empty:
        modelos_ajustados, modelo_info_novo = ajustar_modelos_reologicos(df)
        
        if modelos_ajustados and modelo_info_novo:
            modelo_info = modelo_info_novo
            caminho_json_novo = os.path.join(caminho_pasta, f"{os.path.splitext(os.path.basename(caminho_csv_usado))[0]}_parametros_modelos.json")
            try:
                with open(caminho_json_novo, 'w', encoding='utf-8') as f:
                    json.dump({"modelos_ajustados": modelos_ajustados}, f, indent=4)
                print(f"INFO: Parâmetros dos modelos ajustados salvos em '{os.path.basename(caminho_json_novo)}'")
            except Exception as e:
                print(f"ERRO ao salvar novo arquivo JSON de parâmetros: {e}")

    return df, modelo_info

def criar_nome_curto(nome_completo_pasta):
    """Cria um nome mais curto e limpo para a legenda do gráfico."""
    nome_sem_timestamp = re.sub(r'_\d{8}_\d{6}$', '', nome_completo_pasta)
    return nome_sem_timestamp

# -----------------------------------------------------------------------------
# --- FUNÇÃO DE PLOTAGEM ---
# -----------------------------------------------------------------------------

def plotar_comparativo_com_modelo(dados_analises, coluna_y, coluna_x, titulo, ylabel, xlabel, usar_escala_log=True):
    """
    Cria e retorna uma figura do Matplotlib com a comparação de múltiplas análises.
    """
    fig, ax = plt.subplots(figsize=(12, 8))
    plt.style.use('seaborn-v0_8-whitegrid')
    
    cores = plt.cm.viridis(np.linspace(0, 1, len(dados_analises)))
    marcadores = ['o', 's', '^', 'D', 'v', 'P', '*', 'X']
    
    min_x_vis, max_x_vis = [], []
    min_y_vis, max_y_vis = [], []
    all_y_points_linear = []

    for i, (nome_analise, dados) in enumerate(dados_analises.items()):
        df = dados['df']
        cor = cores[i]
        
        if df is not None and not df.empty:
            # Plota os pontos
            ax.scatter(df[coluna_x], df[coluna_y], marker=marcadores[i % len(marcadores)], color=cor, label=nome_analise, zorder=10, alpha=0.9, s=50)
            # Plota linha ligando os pontos
            ax.plot(df[coluna_x], df[coluna_y], linestyle='-', color=cor, alpha=0.7, linewidth=2)
            
            min_x_vis.append(df[coluna_x].min())
            max_x_vis.append(df[coluna_x].max())
            min_y_vis.append(df[coluna_y].min())
            max_y_vis.append(df[coluna_y].max())
            if not usar_escala_log:
                all_y_points_linear.extend(df[coluna_y].tolist())

    if not min_x_vis:
        print(f"AVISO: Nenhum dado válido para plotar o gráfico '{titulo}'.")
        plt.close(fig)
        return None

    ax.set_title(titulo, fontsize=16, weight='bold')
    ax.set_ylabel(ylabel, fontsize=12)
    ax.set_xlabel(xlabel, fontsize=12)
    
    if usar_escala_log:
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.set_xlim(min(min_x_vis) * 0.8, max(max_x_vis) * 1.2)
    else:
        ax.set_xscale('linear')
        ax.set_yscale('linear')
        ax.set_xlim(left=0, right=max(max_x_vis) * 1.05)
        
        if coluna_y == 'η (Pa·s)' and all_y_points_linear:
            p98 = np.percentile(all_y_points_linear, 98)
            ax.set_ylim(bottom=0, top=p98 * 1.2)
        else:
            ax.set_ylim(bottom=0, top=max(max_y_vis) * 1.05)
        
    ax.legend(title="Amostras", fontsize=10, loc='best')
    fig.tight_layout()
    
    return fig


# -----------------------------------------------------------------------------
# --- FUNÇÃO DE ANÁLISE DE DISCREPÂNCIA ---
# -----------------------------------------------------------------------------

def analisar_discrepancia(dados_completos, nome_referencia, pasta_salvamento):
    """
    Calcula a discrepância (MAPE) entre uma análise de referência e as demais,
    baseando-se nos modelos ajustados, dentro de uma faixa de cisalhamento comum.
    """
    print("\n" + "="*60)
    print("--- ANÁLISE DE DISCREPÂNCIA QUANTITATIVA ---")
    print("="*60)

    if nome_referencia not in dados_completos or 'modelo' not in dados_completos[nome_referencia] or dados_completos[nome_referencia]['modelo'] is None:
        print(f"ERRO: A análise de referência '{nome_referencia}' não possui um modelo ajustado válido.")
        return

    ref_data = dados_completos[nome_referencia]
    ref_model_func = MODELS[ref_data['modelo']['name']][0]
    ref_params = ref_data['modelo']['params']

    faixas_individuais = {}
    for nome, dados in dados_completos.items():
        if dados.get('df') is not None and not dados['df'].empty and dados.get('modelo') is not None:
            min_gamma = dados['df']['γ̇w (s⁻¹)'].min()
            max_gamma = dados['df']['γ̇w (s⁻¹)'].max()
            faixas_individuais[nome] = (min_gamma, max_gamma)
    
    if len(faixas_individuais) < 2:
        print("ERRO: É necessário ter pelo menos duas amostras com modelos e dados válidos para comparar.")
        return

    min_gammas = [v[0] for v in faixas_individuais.values()]
    max_gammas = [v[1] for v in faixas_individuais.values()]
    
    gamma_min_comum = max(min_gammas)
    gamma_max_comum = min(max_gammas)

    if gamma_min_comum >= gamma_max_comum:
        print("AVISO: Análise de discrepância não pode ser executada.")
        print("       Não há uma faixa de sobreposição de taxas de cisalhamento entre todas as amostras válidas.")
        print("\nFaixas de medição individuais (γ̇):")
        for nome, (g_min, g_max) in faixas_individuais.items():
            print(f"  - {nome}: {g_min:.2f} a {g_max:.2f} 1/s")
        print(f"\nO início da faixa comum seria {gamma_min_comum:.2f}, e o fim seria {gamma_max_comum:.2f}.")
        return

    print(f"Análise de Referência: {nome_referencia}")
    print(f"Faixa de comparação (γ̇): {gamma_min_comum:.2f} a {gamma_max_comum:.2f} 1/s")

    gamma_comum = np.logspace(np.log10(gamma_min_comum), np.log10(gamma_max_comum), 200)
    tau_ref = ref_model_func(gamma_comum, *ref_params)
    eta_ref = tau_ref / np.maximum(gamma_comum, 1e-9)
    
    resultados_discrepancia = []

    for nome_analise, dados_analise in dados_completos.items():
        if nome_analise == nome_referencia or nome_analise not in faixas_individuais:
            continue
            
        model_func = MODELS[dados_analise['modelo']['name']][0]
        params = dados_analise['modelo']['params']
        tau_comp = model_func(gamma_comum, *params)
        eta_comp = tau_comp / np.maximum(gamma_comum, 1e-9)

        mape_tau = 100 * np.mean(np.abs((tau_comp - tau_ref) / tau_ref))
        mape_eta = 100 * np.mean(np.abs((eta_comp - eta_ref) / eta_ref))
        
        resultados_discrepancia.append({
            "Amostra Comparada": nome_analise,
            "Referência": nome_referencia,
            "Modelo Comparado": dados_analise['modelo']['name'],
            "MAPE τw (%)": f"{mape_tau:.2f}",
            "MAPE η (%)": f"{mape_eta:.2f}"
        })

    if not resultados_discrepancia:
        print("Nenhuma outra amostra com modelo válido para comparar.")
        return

    df_discrepancia = pd.DataFrame(resultados_discrepancia)
    print("\nResultados da Análise de Discrepância (MAPE %):")
    print(df_discrepancia.to_string(index=False))

    nome_arquivo_csv = os.path.join(pasta_salvamento, "Analise_Discrepancia.csv")
    try:
        df_discrepancia.to_csv(nome_arquivo_csv, index=False, sep=';', decimal=',')
        print(f"\nResultados da discrepância salvos em: {os.path.basename(nome_arquivo_csv)}")
    except Exception as e:
        print(f"ERRO ao salvar o arquivo de discrepância: {e}")

# -----------------------------------------------------------------------------
# --- BLOCO PRINCIPAL DE EXECUÇÃO ---
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    caminho_base_resultados = "resultados_analise_reologica"
    caminho_base_comparativos = "comparativo_analises"

    if not os.path.exists(caminho_base_resultados):
        os.makedirs(caminho_base_resultados)
        print(f"Pasta de resultados '{caminho_base_resultados}' não encontrada. Criando pasta...")
        print("Por favor, coloque as pastas de cada análise dentro de 'resultados_analise_reologica' e execute novamente.")
        exit()
        
    if not os.path.exists(caminho_base_comparativos):
        os.makedirs(caminho_base_comparativos)
        print(f"Pasta '{caminho_base_comparativos}' criada para salvar os resultados.")
    
    pastas_selecionadas = selecionar_pastas_analise(caminho_base_resultados)
    
    if pastas_selecionadas:
        nomes_curtos_analises = [criar_nome_curto(os.path.basename(p)) for p in pastas_selecionadas]
        
        nome_comparativo = "+".join(sorted(list(set(nomes_curtos_analises))))
        timestamp_comparativo = datetime.now().strftime("%Y%m%d_%H%M%S")
        pasta_salvamento = os.path.join(caminho_base_comparativos, f"{nome_comparativo}_{timestamp_comparativo}")
        
        if not os.path.exists(pasta_salvamento):
            os.makedirs(pasta_salvamento)
        
        print(f"\nOs resultados comparativos serão salvos em: {os.path.basename(pasta_salvamento)}")

        dados_completos = {}
        for i, pasta in enumerate(pastas_selecionadas):
            nome_curto = nomes_curtos_analises[i]
            sufixo = 1
            nome_final = nome_curto
            while nome_final in dados_completos:
                sufixo += 1
                nome_final = f"{nome_curto}_{sufixo}"

            df_analise, modelo_info = carregar_dados_completos(pasta)
            
            if df_analise is not None:
                dados_completos[nome_final] = {'df': df_analise, 'modelo': modelo_info}
        
        if not dados_completos:
             print("\nERRO: Nenhuma análise válida foi carregada. Encerrando.")
        else:
            print("\n--- Gerando e Salvando Gráficos Comparativos ---")
            
            plot_configs = [
                {'col_y': 'τw (Pa)', 'col_x': 'γ̇w (s⁻¹)', 'title': 'Comparativo de Curvas de Fluxo (Escala Log)', 'ylabel': r'Tensão de Cisalhamento ($\tau_w$, Pa)', 'xlabel': r'Taxa de Cisalhamento ($\dot{\gamma}_w$, 1/s)', 'log': True, 'fname': 'Comparativo_Fluxo_Log.png'},
                {'col_y': 'η (Pa·s)', 'col_x': 'γ̇w (s⁻¹)', 'title': 'Comparativo de Curvas de Viscosidade (Escala Log)', 'ylabel': r'Viscosidade ($\eta$, Pa·s)', 'xlabel': r'Taxa de Cisalhamento ($\dot{\gamma}_w$, 1/s)', 'log': True, 'fname': 'Comparativo_Viscosidade_Log.png'},
                {'col_y': 'τw (Pa)', 'col_x': 'γ̇w (s⁻¹)', 'title': 'Comparativo de Curvas de Fluxo (Escala Linear)', 'ylabel': r'Tensão de Cisalhamento ($\tau_w$, Pa)', 'xlabel': r'Taxa de Cisalhamento ($\dot{\gamma}_w$, 1/s)', 'log': False, 'fname': 'Comparativo_Fluxo_Linear.png'},
                {'col_y': 'η (Pa·s)', 'col_x': 'γ̇w (s⁻¹)', 'title': 'Comparativo de Curvas de Viscosidade (Escala Linear)', 'ylabel': r'Viscosidade ($\eta$, Pa·s)', 'xlabel': r'Taxa de Cisalhamento ($\dot{\gamma}_w$, 1/s)', 'log': False, 'fname': 'Comparativo_Viscosidade_Linear.png'}
            ]

            figures = []
            for config in plot_configs:
                fig = plotar_comparativo_com_modelo(dados_completos, config['col_y'], config['col_x'], config['title'], config['ylabel'], config['xlabel'], usar_escala_log=config['log'])
                if fig:
                    try:
                        caminho_completo = os.path.join(pasta_salvamento, config['fname'])
                        fig.savefig(caminho_completo, dpi=300, bbox_inches='tight')
                        print(f"Gráfico salvo em: {config['fname']}")
                        figures.append(fig)
                    except Exception as e:
                        print(f"ERRO ao salvar o gráfico '{config['fname']}': {e}")

            if len(dados_completos) > 1:
                realizar_analise = input("\nDeseja realizar a análise de discrepância quantitativa? (s/n): ").strip().lower()
                if realizar_analise == 's':
                    print("\nSelecione a análise de REFERÊNCIA para a comparação:")
                    lista_nomes_validos = [nome for nome, dados in dados_completos.items() if 'modelo' in dados and dados['modelo']]
                    
                    if len(lista_nomes_validos) < 2:
                        print("ERRO: É necessário ter pelo menos duas amostras com modelos ajustados para realizar a comparação.")
                    else:
                        for i, nome in enumerate(lista_nomes_validos):
                            print(f"  {i+1}: {nome}")
                        
                        try:
                            escolha_ref_str = input("Digite o NÚMERO da amostra de referência: ")
                            indice_ref = int(escolha_ref_str.strip()) - 1
                            if 0 <= indice_ref < len(lista_nomes_validos):
                                nome_referencia = lista_nomes_validos[indice_ref]
                                analisar_discrepancia(dados_completos, nome_referencia, pasta_salvamento)
                            else:
                                print("ERRO: Escolha inválida.")
                        except (ValueError, IndexError):
                            print("ERRO: Entrada inválida. A análise de discrepância não será executada.")
            
            try:
                if figures and plt.get_backend():
                     print("\nExibindo gráficos... Feche as janelas para finalizar o script.")
                     plt.show()
                elif figures:
                     for fig in figures:
                         plt.close(fig)
            except Exception as e:
                print(f"\nNão foi possível exibir os gráficos interativamente ({e}). Eles já foram salvos na pasta de resultados.")

    print("\n--- FIM DA COMPARAÇÃO ---")
